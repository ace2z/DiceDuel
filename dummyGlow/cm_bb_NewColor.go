package main

import (
	// = = = = = Native Libraries
	. "github.com/ace2z/GOGO/REFGADS/BLOX"
	. "github.com/ace2z/GOGO/REFGADS/ColorOPS"
	//"github.com/fatih/color"
	//"sort"
	//"strconv"
	//"strings"
	//"fmt"
	"strings"
)

// *************************** MAIN AREA ****************************

func get_from_matrix(lookfor string) (int, int, []string) {
	PLACEHOLDER()
	COLOR_PLACEHOLDER()

	lookfor = strings.ToLower(lookfor)

	for _, item := range COLOR_MATRIX {
		matrix_desc := strings.ToLower(item.DESC)
		matrix_id := strings.ToLower(item.ID)
		if matrix_desc == lookfor {
			return item.FG, item.BG, item.ATTRS
		}
		if matrix_id == lookfor {
			return item.FG, item.BG, item.ATTRS
		}

		filter_desc := strings.ReplaceAll(matrix_desc, color_PREF, "")
		filter_lookfor := strings.ReplaceAll(lookfor, color_PREF, "")
		if filter_desc == filter_lookfor {
			return item.FG, item.BG, item.ATTRS
		}
	}
	return -69, -69, nil
}

func NewColor(params ...interface{}) *CLR_OBJ {
	var vals []int
	var attrs []string

	var other []string

	for _, param := range params {
		str_val, isSTR := param.(string)
		int_val, isINT := param.(int)
		clr_obj, isCLR := param.(CLR_OBJ) // If generated by USER
		// First val is assumed to be the foreground... second is the background
		if isINT {
			vals = append(vals, int_val)
			continue
		}

		if isCLR {
			vals = append(vals, clr_obj.FG)
			vals = append(vals, clr_obj.BG)
			attrs = append(attrs, clr_obj.ATTRS...)
			continue
		}

		if isSTR == false {
			continue
		}

		// Any strings passed in are assumed to be attributes
		tmp_filter := strings.TrimPrefix(str_val, param_PREF)
		if str_val == C_BOLD {
			attrs = append(attrs, tmp_filter+"|"+escBOLD)
			continue
		}
		if str_val == C_BLINK {
			attrs = append(attrs, tmp_filter+"|"+escBLINK)
			continue
		}
		if str_val == C_UNDER {
			attrs = append(attrs, tmp_filter+"|"+escUNDER)
			continue
		}
		if str_val == C_REVERSE {
			attrs = append(attrs, tmp_filter+"|"+escREVERSE)
			continue
		}

		// Ano other strings are assumed to be existing matrix items.
		// If something is added to teh matrix (prior to calling NewColor)
		// It will be found when we search
		other = append(other, str_val)

	} //end of for

	// SHOW_STRUCT(vals)
	// SHOW_STRUCT(attrs)
	// PressAny()
	// SHOW_STRUCT(other)
	// PressAny()

	// Defaults for the terminal
	var fgnum = 7 //white
	var bgnum = 0 // black
	if len(vals) > 0 {
		fgnum = vals[0]
	}
	if len(vals) > 1 {
		bgnum = vals[1]
	}

	// Override. If they specified something already existing in the matrix, we use that for the fgnum
	// Note if TWO items matrix items are in OTHER.. The FIRST matrix item fgnum willbe OUR fgnum. The SECOND items fgnum will become our BGNUM
	// All attributes (if any) will persist

	var tmp_fg_list []int
	for _, obj := range other {

		tmpfg, tmpBG, tmpATTR := get_from_matrix(obj)
		// C.Println(tmpfg, tmpBG)
		// SHOW_STRUCT(tmpATTR, GREEN)
		if tmpfg >= 0 {
			tmp_fg_list = append(tmp_fg_list, tmpfg)
			tmp_fg_list = append(tmp_fg_list, tmpBG)
			attrs = append(attrs, tmpATTR...)
		}
	}

	// SHOW_STRUCT(tmp_fg_list)
	// SHOW_STRUCT(attrs)

	//2. If ONE itemf rom matrix was found and passed, the first two items in tmp_fg_list will be used for fgnum and bgnum
	if len(tmp_fg_list) == 2 {
		fgnum = tmp_fg_list[0]
		bgnum = tmp_fg_list[1]

		// Otherwise if they pased a SECOND item that was found in the matrix, we willhave a 3rd item in the list
		// This THIRD items fgnum will be used for OUR bgnum
		// We NEVER accpet MORE than 2 items from the matrix
	} else if len(tmp_fg_list) > 2 {
		fgnum = tmp_fg_list[0]
		bgnum = tmp_fg_list[2]
	}

	// Now create a new CLR_OBJ object
	//Y.Println(fgnum, bgnum, attrs)
	c := &CLR_OBJ{
		FG:    fgnum,
		BG:    bgnum,
		ATTRS: attrs,
	}

	return c
}
